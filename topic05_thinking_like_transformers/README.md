# "Thinking Like a Transformer"

**Before class on Monday 7 Oct:**

1. Install RASP program from github <https://github.com/tech-srl/RASP>

1. Watch one of the "traditional" explanations of transformers (see topic 3)

1. (optional) See how much of the RASP paper you can understand <http://proceedings.mlr.press/v139/weiss21a.html>

**Monday 7 Oct:**

1. RAG Evaluation homeworks graded

    Most people got full credit

    A few people got -1 point for doing something that annoyed me, e.g.

    1. python files not in the `ragnews` folder

    1. weird binary artifacts in the repos

    A few people got 0 points for not including the accuracy scores where I could find them.

    1. Email me for regrade.

## RASP

We will use RASP to understand what transformers are capable of.

1. Place lower/upper bounds on their compute capabilities.

    For example:
    1. Transformers will never play "perfect NxN chess".
    1. Certain transformers can sort data,
        others cannot.

1. Focus on a "perfectly trained" transformer,
    ignoring the ways that training can reduce performance.

1. RASP is an *esoteric programming language* (esolang) <https://esolangs.org/wiki/Main_Page>

    1. It is a programming language designed to model the transformer architecture.

    1. There are no "real" programs written in this language.

    1. [Alan Perlis](https://en.wikipedia.org/wiki/Alan_Perlis)---first turing award winner---wrote the [epigrams on programming](https://cpsc.yale.edu/epigrams-programming), which include

        <img src=img/perlis.jpg width=400px />

1. Example from the paper:

    <img width=800px src=img/paper-example.png />

<!--1. Norvig: <https://norvig.com/21-days.html>-->

1. RASP has been extended into several python libraries.

    Most notably:

    1. Google Deepmind developed Tracr <https://github.com/google-deepmind/tracr>

        baseline for [mechanistic interpretability research](https://www.transformer-circuits.pub/2022/mech-interp-essay) 

    1. Python-based tutorial: <https://srush.github.io/raspy/>

1. Currently, no tutorials exist for the raw language.

    Everyone who has used RASP has learned it from the research paper.

Author link:

1. <https://gailweiss.github.io/pubs.html>

For the homework:

1. You will need to know how to write RASP code to solve problems.

1. Problems will be either:
    1. Solvable in RASP (and you'll need to provide the implementation)
    1. Not solvable in RASP (and you'll need to explain why)
    1. Unknown whether they are solvable or not (and you can try to either solve them or prove they can't be solved)

### Primitive Sequence Operations

A *sequence operation* (s-op) converts an input sequence of length $n$ into an output sequence of length $n$.
The length cannot be changed.

<!--
1. All sequences in RASP are length $n$ and the length cannot be changed.
1. All RASP programs are written without knowledge of the input sequence length.
    They can be run on sequences of any arbitrary size $n$.
-->

There are two primitive s-ops: `tokens` and `indices`.
These s-ops represent the input information into a transformer.
They can be called similar to functions in python.
```
tokens("hello world");   # identity
indices("hello world");  # convert to the index
```

> **GOTCHA:**
> Notice that the commands are semicolon-terminated.
> Without the semicolon, the command will continue onto the next line.

Strings get tokenized at the character level.
We can tokenize at the word level by passing in a list instead of a string.
```
tokens(["hello", "world"]);
indices(["hello", "world"]);
```

> **NOTE:**
> How tokenization works is an interesting part of transformer/LLM design,
> but it is not relevant to RASP programs.
> RASP assumes that the tokenization has already happened.

RASP supports sequences of type `str`, `bool`, `int`, `double`.
```
tokens([True, True, False]);
tokens([1, 2, 3]);
```

> **NOTE:**
> The string `"hello"` is syntactic sugar for the list `["h", "e", "l", "l", "o"]`.

> **GOTCHA:**
> Applying an s-op to a non-sequence type will generate an error.
> For example:
> ```
> tokens(1);
> ```

S-ops always take exactly one parameter.
If no parameter is provided, a default value of `hello` is used.
```
tokens;
indices;
```

You can change the default example with the `set example` command.
```
set example ["hello", "world"]
tokens;
indices;
```

> **GOTCHA:**
> Notice that the `set example` command is not terminated by a semicolon.
> This is technically because `set example` is not part of the RASP language,
> but a command to the REPL interpreter.
> You will get a weird error message if you put a semicolon after `set example`.

### Defining new s-ops elementwise

New s-ops can be generated by using standard arithmetic operations.
```
indices;
indices + 1;
indices * 2;
```

> **GOTCHA:**
> All mathematical operations are performed on s-ops,
> not on sequences.
> The following is invalid and will generate an error:
> ```
> indices("hello") + 1
> ```
> The error is because `indices("hello")` is a sequence.
> The correct way to add 1 to the indices of `hello` is to generate the new s-op that adds 1 to indices, then apply the new s-op to the sequence `hello`:
> ```
> (indices + 1)("hello")
> ```

New s-ops can be created using standard assignment syntax.
```
i_plus_one = indices + 1;
i_plus_one("hello");
```

Element-wise operations can support s-ops as either argument.
```
indices + indices;
indices * indices;
indices / i_plus_one;
indices + (i_plus_one * indices);
```

Element-wise operations can change the types of the s-ops.
```
indices < 3;
tokens == indices;
```

> **GOTCHA:**
> You can get confusing error messages if your types do not align.
> ```
> set example "hello"
> tokens + 1;
> ```

Types can be cast to other types.
```
indicator(indices < 3);      # convert bool to int
round(indices / 2);          # convert float to int
```

### Basic control flow

RASP is not a *procedural* programming language.
1. It includes if statements, functions, and for loops.
1. But these do not affect the "control flow" through the program like you are used to.

`if` statements are ternary operations applied elementwise.
```
-1 if indices > 1 else 1;
```
> **GOTCHA:**
> You cannot use an if statement to execute some code but not other code.
> All "branches" of the if statement are evaluated.

The `def` keyword can be used to define functions.
The standard library defines the following `min` and `max` functions.
```
def max(a, b) { return a if a>b else b; }
max(indices, 2)

def min(a, b) { return a if a<b else b; }
min(indices, 2)
```

> **GOTCHA:**
> Functions and s-ops look similar in RASP because they both use the standard function application syntax.
> But they are not the same thing.
>
> In normal usage, only functions will have parenthesis next to them.
> S-ops can have parentheses, but they normally do not.
> It more appropriate to think of an s-op as a "vector that keeps track of how it was made" than it is to think of it as a function.

Functions in RASP cannot be defined recursively.
(There would be no way to define a base-case the way if statements are implemented.)
Therefore, functions cannot be used to implement complex control flow.

### Complex control flow

Complex control flow is implemented using the `select` and `aggregate` operations.

1. There is no analog to the functions in other languages like python.
1. Not all programs can be written using thesee functions.
1. If you understand the limits of these functions,
    then you understand the limits of what a transformer can do.

The `select` command constructs a boolean matrix from two inputs s-ops and a comparison operation.

```
select(tokens, tokens, ==);
select(indices, indices, <=);
select(indices, indices + 2, <=);
```

`select` can also take constants as input,
in which case those constants are treated like an s-op that outputs that constant in every position.

```
select(tokens, "l", ==);
select(1, indices, ==);
```

> **GOTCHA:**
> You cannot pass sequences to `select`, only s-ops or scalars.
> The following generates an error:
> ```
> select(indices, [1, 2, 3], ==);
> ```
> The reason for this is that RASP programs must be able to work on inputs of any possible size.

The outputs of the `select` function are called *selectors*.
One commonly useful selector defined in the standard library is
```
full_s = select(1, 1, ==);
```

> **GOTCHA:**
> Selectors are displayed in the repl as 1 or empty,
> but they are more like boolean values than numeric.
> For example, you can perform boolean operations on them:
> ```
> not select(tokens, tokens, ==);
> select(indices, 1, ==) or select(indices, 2, ==);
> ```
> But numeric operations generate an error:
> ```
> select(tokens, tokens, ==) * 2;
> ```

The `aggregate` function converts a selector into an s-op.
It is the most difficult part of RASP to understand.

We will first explain WHAT `aggregate` does,
then we will motivate the WHY.
```
_selector = select(indices, indices, <=);
aggregate(_selector, indices);
```

> **NOTE:**
> Variables prefixed with `_` are intended to be "local". 

When there are no values for a row to average together,
`aggregate` uses a default value of 0.
The optional third argument to `aggregate` specifies this default value.
```
_selector = select(indices, indices, <);
aggregate(_selector, indices);
aggregate(_selector, indices, 42);
```

### Examples

The purpose of these examples is to help understand WHY to use the aggregate and select functions in different combinations.

The RASP standard library defines the `length` s-op as
```
length = round(1/aggregate(full_s,indicator(indices==0)));
```

The following s-op stores the length only in the last token position.
```
_selector = select(indices, length-1, ==) and select(indices, indices, ==);
length_lastloc = aggregate(_selector, indices, -1) + 1;
```

The following s-op reverses the input sequence.
```
reverse = aggregate(select(indices, length-indices-1, ==), tokens);
```

> **GOTCHA:**
> Recall that s-ops and functions are different.
> For example, we cannot use the `reverse` s-op to reverse the indices.
> The following generates an error:
> ```
> reverse(indices);
> ```
> If we wanted that functionality, we would need to define a reverse function:
> ```
> def reverse_func(seq) {
>     return aggregate(select(indices, length-indices-1, ==), seq);
> }
> ```
> this would allow reversing any s-op:
> ```
> reverse_func(tokens);      # equivalent to the original `reverse` s-op
> reverse_func(indices);     # new functionality
> ```
> I find this distinction between s-ops and functions aesthetically displeasing,
> but esolangs often have these weird distinctions.

### Visualizing control flow

We can use the `draw` function to visualize the full control flow of an s-op.
```
draw(length);
draw(length_lastloc);
draw(reverse);
draw(reverse_func(tokens));
draw(reverse_func(indices));
```

### Examples from the standard library

Three more simple examples from the standard library:
```
def average(a) {
    return aggregate(full_s,a);
}

def load_from_location(seq,location) {
    return aggregate(select(indices,location,==),seq);
}

def contains(seq,atom) {
	return aggregate(full_s,indicator(seq==atom))>0;
}
```

One of the most important functions in the standard library is `selector_width`.
```
def selector_width(sel) {
    at0 = select(indices,0,==);
    sAND0 = sel and at0;
    sOR0 = sel or at0;
    inverted = aggregate(sOR0,indicator(indices==0));
    except0 = (1/inverted)-1;
    valat0 = aggregate(sAND0,1,0);
    return round(except0 + valat0);
}
```

Sorting is a standard task that many other tasks reduce to.
The following code implmements an insertion-sort-like $O(n^2)$ sorting algorithm.
```
def sort(seq) {
	select_earlier_in_sorted = 
		select(seq,seq,<) or (select(seq,seq,==) and select(indices,indices,<));
	target_position = 
		selector_width(select_earlier_in_sorted);
	select_new_val = 
		select(target_position,indices,==);
	return aggregate(select_new_val,seq);
}
```

### Types of Attention

What we're using:

1. (2019 NAACL - Google AI Language) BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding <https://arxiv.org/abs/1810.04805>

    ```
    mask_full = select(1, 1, ==);
    ```

Autogenerative:

1. No citation.

    ```
    mask_ag = select(indices, indices, <=);
    ```

    The Llama 1/2/3 series of models all use this token mask.

    Most propietary SOTA architectures "probably" use this mask.

    Anthropic combines this mask with a sparse mask below.

<!--
> **Fun Facts:**
> 1. Autogenerative transformers cannot implement sorting.
-->

Sparse Architectures:

1. (2020 ??? - Allen Institute for AI) Longformer: The Long-Document Transformer
    ```
    def mask_longformer(wsize) {
        gt = select(indices, indices-wsize, >=);
        lt = select(indices, indices+wsize, <=);
        return gt and lt;
    }
    ```

1. (2020 NeurIPS - Google Research) BigBird: Transformers for Longer Sequences <https://arxiv.org/abs/2007.14062>

    longformer mask + more stuff

> **Open Problem:**
> Can merge sort (or any $n\log n$ runtime sorting algorithm) be implemented in a transformer with sparse attention?


## Homework

These problems are in no particular order.
Many of them are closely inspired by functions in the standard library.

Expect more problems posted after fall break.

**Problem 1:**
Write an s-op that contains the indices in reverse order.
For example:
```
> reverse_indices("hello")
[4, 3, 2, 1, 0]
```

**Problem 2:**
Write a function that "rotates" the input text by the specified number of characters.
For example:
```
> rotate(tokens, 0)("hello")
"hello"
> rotate(tokens, 1)("hello")
"ohell"
> rotate(tokens, 2)("hello")
"lohel"
```

**Problem 3:**
Write a function that "rotates" the input text by the specified number of characters.
For example:
```
> rotate(tokens, 0)("hello")
"hello"
> rotate(tokens, 1)("hello")
"ohell"
> rotate(tokens, 2)("hello")
"lohel"
```

**Problem 3:**
Write a function that takes a sequence as input and "swaps every letter with its neighbor".
Specifically, for every even index $i$, positions $i$ and $i+1$ will be swapped.
For example:
```
> swap(tokens)("hello")
"ehllo"
> swap(tokens)("ababab")
"bababa"
```

**Problem 4:**
Write a function that returns the maximum value in the sequence repeated for every position.
For example:
```
> maxseq(tokens)("ababcabab")
"ccccccccc"
```

**Problem 5:**
Write a function that returns the maximum value in the sequnce only of the tokens seen so far.
For example:
```
> maxseq(tokens)("ababcabab")
"abbbccccc"
```

**Problem 6:**
Write a function that performs sequence reversal "autogeneratively".
That is, it will take a sequence as input, and the sequence will contain a special token `$` that marks the "end of the prompt".
The text before the `$` should be unchanged, and the text after the `$` should be the text before the `$` reversed (this text represents the model's response to the prompt).
The code should be robuse to the case when the length of text after `$` is not the same as the length of text before `$`.
For example:
```
> reverse_ag(tokens)("hello$     ")
"hello$olleh"
> reverse_ag(tokens)("hello$ ")
"hello$o"
> reverse_ag(tokens)("hello$X")
"hello$o"
> reverse_ag(tokens)("hello$XXXXXXXXXX")
"hello$olleh     "
```

**Problem 6:**
Write a function that counts the number of times a certain token appears in the input sequence.
For example:
```
> howmany(tokens, "a")("hello")
"00000"
> howmany(tokens, "h")("hello")
"11111"
> howmany(tokens, "l")("hello")
"22222"
```

**Problem 7:**
Write a function that counts the number of times a certain token has appeared in the input sequence so far.
For example:
```
> howmany(tokens, "a")("hello")
"00000"
> howmany(tokens, "h")("hello")
"11111"
> howmany(tokens, "e")("hello")
"01111"
> howmany(tokens, "l")("hello")
"00122"
```


<!--
def sop_max(seq) {
    le = select(tokens, tokens, <=);
    selector_width(le) == length;
}

def swap_neighbors(seq) {
    return aggregate((select(seq, seq, <) or select(seq, seq, >)) and block_s(2), seq);
}

def seqmax(seq) {
    maxloc = selector_width(select(seq, seq, <=)) == length;
    return aggregate(select(indicator(maxloc), 1, ==), seq);
}

## Implications


Transformers can only implement algorithms with runtime $O(kn^2)$

Many problems cannot be solved:

1. Any NP-hard problem <https://en.wikipedia.org/wiki/NP-completeness>

1. "generalized n x n chess"
   
   it is EXPTIME-complete <https://www.sciencedirect.com/science/article/pii/0097316581900169>

1. matrix multiplication has runtime lower bound $\Omega(n^2 \log n)$

## Autogenerative

Sorting cannot be implmemented autogeneratively
-->
